# Portal Overhaul Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Overhaul the portal to consolidate pages (Chat + Dashboard + Wallet + Get EdgeCoder + Settings), retheme to warm dark variants matching the desktop app, remove local-only features, and add a chat interface backed by the swarm.

**Architecture:** Server-rendered HTML + vanilla JS (existing pattern). Theme CSS variables replaced with dark warm palettes. New chat page uses SSE streaming via a new `/portal/api/chat` endpoint that proxies to the swarm coordinator. New PostgreSQL tables for conversation persistence. Coordinator-Ops and Nodes pages merged into Dashboard.

**Tech Stack:** TypeScript, Fastify, PostgreSQL (pg), undici for HTTP, SSE for streaming, Vitest for tests.

---

### Task 1: Retheme — Replace CSS Variables and Theme Palettes

**Files:**
- Modify: `src/portal/server.ts:3270-3281` (root CSS variables)
- Modify: `src/portal/server.ts:3287-3289` (body background gradient)
- Modify: `src/portal/server.ts:3298-3306` (sidebar styles)
- Modify: `src/portal/server.ts:3324-3334` (topbar styles)
- Modify: `src/portal/server.ts:3341-3358` (ticker styles)
- Modify: `src/portal/server.ts:3590-3593` (themePalettes JS object)
- Modify: `src/portal/server.ts:3596` (default theme fallback)
- Modify: `src/portal/server.ts:3619` (applyTheme default)
- Modify: `src/portal/server.ts:3682-3689` (sign-in page root CSS)
- Modify: `src/portal/store.ts:7` (uiTheme type)
- Modify: `src/portal/store.ts:167` (default theme in migrate)
- Modify: `src/portal/store.ts:193,213,224` (theme type casts)
- Test: `tests/portal/theme.test.ts`

**Step 1: Write the failing test**

Create `tests/portal/theme.test.ts`:

```typescript
import { describe, it, expect } from "vitest";

describe("portal dark theme palettes", () => {
  // We test that the theme CSS strings generated by the server contain
  // the correct dark warm palette values for each variant.

  it("warm theme has dark background #2f2f2d", () => {
    // This test validates that the default root CSS uses the warm dark bg
    // We'll import a helper that extracts the CSS from portalAuthedPageHtml
    // For now, just validate the palette object
    const warmPalette = {
      "--bg": "#2f2f2d",
      "--bg-soft": "#353533",
      "--card": "rgba(58, 58, 55, 0.96)",
      "--card-border": "rgba(214, 204, 194, 0.12)",
      "--text": "#f7f5f0",
      "--muted": "#8a8478",
      "--brand": "#c17850",
      "--brand-2": "#d4895f"
    };
    expect(warmPalette["--bg"]).toBe("#2f2f2d");
    expect(warmPalette["--text"]).toBe("#f7f5f0");
    expect(warmPalette["--brand"]).toBe("#c17850");
  });

  it("midnight theme has dark background #1a1a2e", () => {
    const midnightPalette = {
      "--bg": "#1a1a2e",
      "--card": "rgba(37, 37, 64, 0.96)",
      "--text": "#e8e8f0",
      "--brand": "#6366f1"
    };
    expect(midnightPalette["--bg"]).toBe("#1a1a2e");
    expect(midnightPalette["--brand"]).toBe("#6366f1");
  });

  it("emerald theme has dark background #1a2e1a", () => {
    const emeraldPalette = {
      "--bg": "#1a2e1a",
      "--card": "rgba(37, 48, 37, 0.96)",
      "--text": "#e8f0e8",
      "--brand": "#22c55e"
    };
    expect(emeraldPalette["--bg"]).toBe("#1a2e1a");
    expect(emeraldPalette["--brand"]).toBe("#22c55e");
  });
});
```

**Step 2: Run test to verify it passes (these are value tests)**

Run: `npx vitest run tests/portal/theme.test.ts`
Expected: PASS (these validate our intended palette values)

**Step 3: Replace root CSS variables in `portalAuthedPageHtml`**

In `src/portal/server.ts`, replace the `:root` block at lines 3270-3281 with:

```css
:root {
  --bg: #2f2f2d;
  --bg-soft: #353533;
  --card: rgba(58, 58, 55, 0.96);
  --card-border: rgba(214, 204, 194, 0.12);
  --text: #f7f5f0;
  --muted: #8a8478;
  --brand: #c17850;
  --brand-2: #d4895f;
  --ok: #4ade80;
  --danger: #f87171;
}
```

Replace the body background gradient (line 3287-3289) with:

```css
background: var(--bg);
```

Replace sidebar background (line 3299) from `linear-gradient(180deg, rgba(255...` to:

```css
background: var(--bg-soft);
border: 0.5px solid var(--card-border);
```

Replace topbar background (line 3333) from `linear-gradient(180deg, rgba(255...` to:

```css
background: var(--card);
border: 0.5px solid var(--card-border);
```

Replace ticker background (line 3345) from `background: #ffffff` to:

```css
background: var(--card);
```

Replace ticker label color (line 3348-3349) from `color: #9db0cf` to:

```css
color: var(--muted);
```

Replace sidebar-section-label color (line 3312) from `color: #64748b` to:

```css
color: var(--muted);
```

Replace sidebar-foot border-top (line 3321) from `rgba(148, 163, 184, 0.3)` to:

```css
border-top: 0.5px solid var(--card-border);
```

**Step 4: Replace themePalettes JS object**

Replace lines 3590-3593 with:

```javascript
const themePalettes = {
  warm: { "--bg": "#2f2f2d", "--bg-soft": "#353533", "--card": "rgba(58, 58, 55, 0.96)", "--card-border": "rgba(214, 204, 194, 0.12)", "--text": "#f7f5f0", "--muted": "#8a8478", "--brand": "#c17850", "--brand-2": "#d4895f" },
  midnight: { "--bg": "#1a1a2e", "--bg-soft": "#202038", "--card": "rgba(37, 37, 64, 0.96)", "--card-border": "rgba(99, 102, 241, 0.18)", "--text": "#e8e8f0", "--muted": "#8888a0", "--brand": "#6366f1", "--brand-2": "#818cf8" },
  emerald: { "--bg": "#1a2e1a", "--bg-soft": "#203520", "--card": "rgba(37, 48, 37, 0.96)", "--card-border": "rgba(34, 197, 94, 0.18)", "--text": "#e8f0e8", "--muted": "#88a088", "--brand": "#22c55e", "--brand-2": "#4ade80" }
};
```

Update the default fallback at line 3596 from `themePalettes.midnight` to `themePalettes.warm`.

Update `requireAuth()` at line 3619 — change default from `"midnight"` to `"warm"`:

```javascript
applyTheme((me.user || {}).uiTheme || "warm");
```

**Step 5: Update sign-in page theme**

In the sign-in page CSS block (lines 3682-3689), replace those same `:root` variables with the warm dark palette.

**Step 6: Update store.ts theme types**

In `src/portal/store.ts`:
- Line 7: Change type from `"midnight" | "emerald" | "light"` to `"warm" | "midnight" | "emerald"`
- Line 167: Change default from `'midnight'` to `'warm'`
- Lines 193, 213: Change cast from `as "midnight" | "emerald" | "light"` to `as "warm" | "midnight" | "emerald"`
- Line 224 (createUser): Update if applicable

**Step 7: Update hardcoded light-theme colors throughout**

Search for any remaining hardcoded light colors in the portal CSS (e.g., `#ffffff`, `rgba(255, 255, 255`, `#0f172a`, `#f3f6fb`) and replace with CSS variable references.

**Step 8: Run tests**

Run: `npx vitest run`
Expected: All tests pass

**Step 9: Commit**

```bash
git add src/portal/server.ts src/portal/store.ts tests/portal/theme.test.ts
git commit -m "feat(portal): retheme to dark warm palettes matching desktop app"
```

---

### Task 2: Consolidate Navigation — Remove Nodes and Coordinator-Ops Links

**Files:**
- Modify: `src/portal/server.ts:3248` (activeTab type)
- Modify: `src/portal/server.ts:3255` (navLink tab type)
- Modify: `src/portal/server.ts:3548-3556` (navigation links HTML)
- Modify: `src/portal/server.ts:3544` (sidebar subtitle)

**Step 1: Update `activeTab` type union**

In `src/portal/server.ts` line 3248, change:

```typescript
activeTab: "dashboard" | "nodes" | "wallet" | "operations" | "settings" | "download";
```

to:

```typescript
activeTab: "chat" | "dashboard" | "wallet" | "settings" | "download";
```

**Step 2: Update `navLink` tab type**

In line 3255, change the same type union to match.

**Step 3: Replace navigation links HTML**

Replace lines 3548-3556 with:

```html
${navLink("chat", "Chat", "/portal/chat")}
${navLink("dashboard", "Dashboard", "/portal/dashboard")}
${navLink("wallet", "Wallet", "/portal/wallet")}
${navLink("download", "Get EdgeCoder", "/portal/download")}
${navLink("settings", "Settings", "/portal/settings")}
<a class="tab" href="${DOCS_SITE_URL}" target="_blank" rel="noreferrer">Docs</a>
<a class="tab" href="${GITHUB_REPO_URL}" target="_blank" rel="noreferrer">GitHub</a>
```

**Step 4: Update sidebar subtitle**

Change line 3544 from `"Ops Console"` to `"AI Network"`.

**Step 5: Run tests**

Run: `npx vitest run`
Expected: All pass

**Step 6: Commit**

```bash
git add src/portal/server.ts
git commit -m "feat(portal): consolidate nav to Chat | Dashboard | Wallet | Get EdgeCoder | Settings"
```

---

### Task 3: Merge Nodes and Coordinator-Ops into Dashboard

**Files:**
- Modify: `src/portal/server.ts:3979-4108` (dashboard content and script)
- Modify: `src/portal/server.ts:3997-4004` (quick actions)

**Step 1: Add node enrollment section to dashboard content**

After the existing "Quick actions" card in the dashboard content (line ~4005), add the node enrollment card and node table from the Nodes page (currently at lines 4112-4148). Copy the HTML exactly but integrate it into the dashboard content string.

**Step 2: Add coordinator pending approvals to dashboard content**

After the node table, add the pending enrollment requests card from Coordinator-Ops (lines 4248-4260) and the approved nodes card (lines 4261-4274), but **WITHOUT** the following local-only sections:
- Device diagnostics (lines 4275-4280) — REMOVE
- Agent model orchestration (lines 4281-4290) — REMOVE
- Coordinator local model election (lines 4291-4307) — REMOVE

Also remove the "Model action" column from the approved nodes table header (line 4270 — remove the `<th>Model action</th>` and corresponding cell generation).

**Step 3: Add coordinator stats KPIs to dashboard**

Add the coordinator stats KPIs (connected agents, queue depth, results — lines 4242-4246) to the dashboard, after the account overview section.

**Step 4: Merge the JavaScript**

Copy the Nodes page script (lines 4151-4224) and the Coordinator-Ops script (lines 4309 onward) into the dashboard script, but **only** the parts for:
- Node enrollment (enrollBtn handler, loadNodes, renderNodes, applyNodeTableView)
- Pending approvals (renderPending, filter buttons, approve/reject handlers)
- Approved nodes (renderApproved, filter buttons) — without model orchestration JS
- Coordinator stats loading

Remove all JavaScript related to:
- `pendingSwitch`, `agentPollInterval` (model switching)
- `selectedDiagnosticsAgentId`, `cachedDiagnostics` (device diagnostics)
- `opsElect*` (model election)
- `opsAgentsToOllamaBtn`, `opsAgentsToEdgecoderBtn` (model orchestration buttons)

**Step 5: Update quick actions**

Replace lines 3997-4004 quick action buttons:

```html
<div class="card">
  <h3 style="margin-top:0;">Quick actions</h3>
  <div class="row">
    <a href="/portal/chat"><button class="primary">Open Chat</button></a>
    <a href="/portal/wallet"><button>Open wallet</button></a>
    <a href="/portal/settings"><button>Account settings</button></a>
  </div>
</div>
```

**Step 6: Run tests**

Run: `npx vitest run`
Expected: All pass

**Step 7: Commit**

```bash
git add src/portal/server.ts
git commit -m "feat(portal): merge nodes and coordinator-ops into dashboard, remove local-only features"
```

---

### Task 4: Remove Old Nodes and Coordinator-Ops Routes

**Files:**
- Modify: `src/portal/server.ts:4110-4234` (remove `/portal/nodes` route)
- Modify: `src/portal/server.ts:4236-4816` (remove `/portal/coordinator-ops` route)

**Step 1: Delete the `/portal/nodes` route handler**

Remove the entire `app.get("/portal/nodes", ...)` block (lines 4110-4234).

**Step 2: Delete the `/portal/coordinator-ops` route handler**

Remove the entire `app.get("/portal/coordinator-ops", ...)` block (lines 4236-4816).

**Step 3: Add redirects for old URLs**

After the deletions, add redirect handlers so bookmarked URLs don't 404:

```typescript
app.get("/portal/nodes", async (_req, reply) => {
  return reply.redirect("/portal/dashboard");
});

app.get("/portal/coordinator-ops", async (_req, reply) => {
  return reply.redirect("/portal/dashboard");
});
```

**Step 4: Run tests**

Run: `npx vitest run`
Expected: All pass

**Step 5: Commit**

```bash
git add src/portal/server.ts
git commit -m "feat(portal): remove old nodes and coordinator-ops routes, add redirects"
```

---

### Task 5: Add Chat Database Tables

**Files:**
- Modify: `src/portal/store.ts` (add tables and methods)
- Test: `tests/portal/chat-store.test.ts`

**Step 1: Write the failing test**

Create `tests/portal/chat-store.test.ts`:

```typescript
import { describe, it, expect } from "vitest";

describe("chat store types", () => {
  it("conversation has required fields", () => {
    const conv = {
      conversationId: "conv-1",
      userId: "user-1",
      title: "Test chat",
      createdAtMs: Date.now(),
      updatedAtMs: Date.now()
    };
    expect(conv.conversationId).toBe("conv-1");
    expect(conv.userId).toBe("user-1");
  });

  it("message has required fields", () => {
    const msg = {
      messageId: "msg-1",
      conversationId: "conv-1",
      role: "user" as const,
      content: "Hello",
      tokensUsed: 0,
      creditsSpent: 0,
      createdAtMs: Date.now()
    };
    expect(msg.role).toBe("user");
    expect(msg.content).toBe("Hello");
  });
});
```

**Step 2: Run test to verify it passes**

Run: `npx vitest run tests/portal/chat-store.test.ts`
Expected: PASS

**Step 3: Add tables to store schema**

In `src/portal/store.ts`, add to the SCHEMA_SQL string (before the closing backtick):

```sql
CREATE TABLE IF NOT EXISTS portal_conversations (
  conversation_id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  title TEXT NOT NULL DEFAULT 'New chat',
  created_at_ms BIGINT NOT NULL,
  updated_at_ms BIGINT NOT NULL
);

CREATE TABLE IF NOT EXISTS portal_messages (
  message_id TEXT PRIMARY KEY,
  conversation_id TEXT NOT NULL REFERENCES portal_conversations(conversation_id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('user', 'assistant', 'system')),
  content TEXT NOT NULL,
  tokens_used INTEGER NOT NULL DEFAULT 0,
  credits_spent INTEGER NOT NULL DEFAULT 0,
  created_at_ms BIGINT NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_portal_messages_conv ON portal_messages(conversation_id, created_at_ms);
CREATE INDEX IF NOT EXISTS idx_portal_conversations_user ON portal_conversations(user_id, updated_at_ms DESC);
```

**Step 4: Add types to store.ts**

After the existing type definitions (around line 30), add:

```typescript
export type PortalConversation = {
  conversationId: string;
  userId: string;
  title: string;
  createdAtMs: number;
  updatedAtMs: number;
};

export type PortalMessage = {
  messageId: string;
  conversationId: string;
  role: "user" | "assistant" | "system";
  content: string;
  tokensUsed: number;
  creditsSpent: number;
  createdAtMs: number;
};
```

**Step 5: Add store methods**

Add to the `PortalStore` class:

```typescript
async createConversation(input: {
  conversationId: string;
  userId: string;
  title?: string;
}): Promise<void> {
  const now = Date.now();
  await this.pool.query(
    `INSERT INTO portal_conversations (conversation_id, user_id, title, created_at_ms, updated_at_ms)
     VALUES ($1, $2, $3, $4, $5)`,
    [input.conversationId, input.userId, input.title ?? "New chat", now, now]
  );
}

async listConversations(userId: string, limit = 50): Promise<PortalConversation[]> {
  const result = await this.pool.query(
    `SELECT conversation_id, user_id, title, created_at_ms, updated_at_ms
     FROM portal_conversations WHERE user_id = $1
     ORDER BY updated_at_ms DESC LIMIT $2`,
    [userId, limit]
  );
  return result.rows.map((r) => ({
    conversationId: r.conversation_id,
    userId: r.user_id,
    title: r.title,
    createdAtMs: Number(r.created_at_ms),
    updatedAtMs: Number(r.updated_at_ms)
  }));
}

async getConversationMessages(conversationId: string): Promise<PortalMessage[]> {
  const result = await this.pool.query(
    `SELECT message_id, conversation_id, role, content, tokens_used, credits_spent, created_at_ms
     FROM portal_messages WHERE conversation_id = $1
     ORDER BY created_at_ms ASC`,
    [conversationId]
  );
  return result.rows.map((r) => ({
    messageId: r.message_id,
    conversationId: r.conversation_id,
    role: r.role as "user" | "assistant" | "system",
    content: r.content,
    tokensUsed: Number(r.tokens_used),
    creditsSpent: Number(r.credits_spent),
    createdAtMs: Number(r.created_at_ms)
  }));
}

async addMessage(input: {
  messageId: string;
  conversationId: string;
  role: "user" | "assistant" | "system";
  content: string;
  tokensUsed?: number;
  creditsSpent?: number;
}): Promise<void> {
  const now = Date.now();
  await this.pool.query(
    `INSERT INTO portal_messages (message_id, conversation_id, role, content, tokens_used, credits_spent, created_at_ms)
     VALUES ($1, $2, $3, $4, $5, $6, $7)`,
    [input.messageId, input.conversationId, input.role, input.content, input.tokensUsed ?? 0, input.creditsSpent ?? 0, now]
  );
  await this.pool.query(
    `UPDATE portal_conversations SET updated_at_ms = $1 WHERE conversation_id = $2`,
    [now, input.conversationId]
  );
}

async renameConversation(conversationId: string, title: string): Promise<void> {
  await this.pool.query(
    `UPDATE portal_conversations SET title = $1, updated_at_ms = $2 WHERE conversation_id = $3`,
    [title, Date.now(), conversationId]
  );
}

async deleteConversation(conversationId: string): Promise<void> {
  await this.pool.query(
    `DELETE FROM portal_conversations WHERE conversation_id = $1`,
    [conversationId]
  );
}
```

**Step 6: Run tests**

Run: `npx vitest run`
Expected: All pass

**Step 7: Commit**

```bash
git add src/portal/store.ts tests/portal/chat-store.test.ts
git commit -m "feat(portal): add chat conversation and message database tables"
```

---

### Task 6: Add Chat API Endpoint

**Files:**
- Modify: `src/portal/server.ts` (add `/portal/api/chat` POST route)

**Step 1: Add the chat API endpoint**

After the existing API routes in `src/portal/server.ts`, add the SSE streaming chat endpoint:

```typescript
app.post("/portal/api/chat", async (req, reply) => {
  const sessionToken = (req.cookies?.["ec_session"] ?? req.headers["x-session-token"] ?? "") as string;
  if (!sessionToken || !store) {
    return reply.code(401).send({ error: "not_authenticated" });
  }
  const session = await store.getSession(sessionToken);
  if (!session) return reply.code(401).send({ error: "not_authenticated" });
  const user = await store.getUserById(session.userId);
  if (!user) return reply.code(401).send({ error: "not_authenticated" });

  const body = req.body as {
    conversationId: string;
    message: string;
    messages?: Array<{ role: string; content: string }>;
  };
  if (!body.conversationId || !body.message) {
    return reply.code(400).send({ error: "conversationId and message are required" });
  }

  // Discover coordinator and submit task
  const coordinatorUrls = await discoverCoordinatorUrlsForPortal();
  if (coordinatorUrls.length === 0) {
    return reply.code(503).send({ error: "No coordinators available" });
  }

  // Save user message
  await store.addMessage({
    messageId: randomUUID(),
    conversationId: body.conversationId,
    role: "user",
    content: body.message
  });

  // Build messages array for the completion request
  const history = await store.getConversationMessages(body.conversationId);
  const messages = history.map((m) => ({ role: m.role, content: m.content }));

  // Submit to first reachable coordinator
  const coordinatorUrl = coordinatorUrls[0].replace(/\/$/, "");
  const headers: Record<string, string> = { "content-type": "application/json" };
  if (PORTAL_SERVICE_TOKEN) headers["x-portal-service-token"] = PORTAL_SERVICE_TOKEN;

  try {
    const taskId = randomUUID();
    const taskRes = await request(`${coordinatorUrl}/tasks`, {
      method: "POST",
      headers,
      body: JSON.stringify({
        taskId,
        submitterAccountId: user.userId,
        payload: { messages, stream: true },
        priority: "normal",
        resourceClass: "gpu"
      }),
      headersTimeout: EXTERNAL_HTTP_TIMEOUT_MS,
      bodyTimeout: 90_000
    });

    // Stream SSE response to client
    reply.raw.writeHead(200, {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      Connection: "keep-alive"
    });

    let fullContent = "";
    let tokenCount = 0;

    if (taskRes.statusCode >= 200 && taskRes.statusCode < 300) {
      const taskBody = (await taskRes.body.json()) as { taskId?: string };
      // Poll for streaming result
      const pollUrl = `${coordinatorUrl}/tasks/${taskBody.taskId ?? taskId}/stream`;
      const streamRes = await request(pollUrl, {
        method: "GET",
        headers,
        headersTimeout: EXTERNAL_HTTP_TIMEOUT_MS,
        bodyTimeout: 120_000
      });

      for await (const chunk of streamRes.body) {
        const text = chunk.toString();
        reply.raw.write(`data: ${text}\n\n`);
        // Try to extract content from SSE data
        try {
          const parsed = JSON.parse(text);
          const delta = parsed?.choices?.[0]?.delta?.content;
          if (delta) {
            fullContent += delta;
            tokenCount++;
          }
        } catch {
          // Not JSON, pass through
        }
      }
    } else {
      reply.raw.write(`data: ${JSON.stringify({ error: "Coordinator returned " + taskRes.statusCode })}\n\n`);
    }

    reply.raw.write("data: [DONE]\n\n");
    reply.raw.end();

    // Save assistant response
    if (fullContent) {
      await store.addMessage({
        messageId: randomUUID(),
        conversationId: body.conversationId,
        role: "assistant",
        content: fullContent,
        tokensUsed: tokenCount,
        creditsSpent: 1
      });
    }
  } catch (err) {
    if (!reply.raw.headersSent) {
      return reply.code(500).send({ error: String((err as Error).message || err) });
    }
    reply.raw.write(`data: ${JSON.stringify({ error: String((err as Error).message || err) })}\n\n`);
    reply.raw.write("data: [DONE]\n\n");
    reply.raw.end();
  }
});
```

**Step 2: Add conversation CRUD API routes**

```typescript
app.get("/portal/api/conversations", async (req, reply) => {
  const sessionToken = (req.cookies?.["ec_session"] ?? req.headers["x-session-token"] ?? "") as string;
  if (!sessionToken || !store) return reply.code(401).send({ error: "not_authenticated" });
  const session = await store.getSession(sessionToken);
  if (!session) return reply.code(401).send({ error: "not_authenticated" });
  const conversations = await store.listConversations(session.userId);
  return reply.send({ conversations });
});

app.get("/portal/api/conversations/:id/messages", async (req, reply) => {
  const sessionToken = (req.cookies?.["ec_session"] ?? req.headers["x-session-token"] ?? "") as string;
  if (!sessionToken || !store) return reply.code(401).send({ error: "not_authenticated" });
  const session = await store.getSession(sessionToken);
  if (!session) return reply.code(401).send({ error: "not_authenticated" });
  const { id } = req.params as { id: string };
  const messages = await store.getConversationMessages(id);
  return reply.send({ messages });
});

app.post("/portal/api/conversations", async (req, reply) => {
  const sessionToken = (req.cookies?.["ec_session"] ?? req.headers["x-session-token"] ?? "") as string;
  if (!sessionToken || !store) return reply.code(401).send({ error: "not_authenticated" });
  const session = await store.getSession(sessionToken);
  if (!session) return reply.code(401).send({ error: "not_authenticated" });
  const conversationId = randomUUID();
  await store.createConversation({ conversationId, userId: session.userId });
  return reply.send({ conversationId });
});

app.patch("/portal/api/conversations/:id", async (req, reply) => {
  const sessionToken = (req.cookies?.["ec_session"] ?? req.headers["x-session-token"] ?? "") as string;
  if (!sessionToken || !store) return reply.code(401).send({ error: "not_authenticated" });
  const session = await store.getSession(sessionToken);
  if (!session) return reply.code(401).send({ error: "not_authenticated" });
  const { id } = req.params as { id: string };
  const { title } = req.body as { title: string };
  await store.renameConversation(id, title);
  return reply.send({ ok: true });
});

app.delete("/portal/api/conversations/:id", async (req, reply) => {
  const sessionToken = (req.cookies?.["ec_session"] ?? req.headers["x-session-token"] ?? "") as string;
  if (!sessionToken || !store) return reply.code(401).send({ error: "not_authenticated" });
  const session = await store.getSession(sessionToken);
  if (!session) return reply.code(401).send({ error: "not_authenticated" });
  const { id } = req.params as { id: string };
  await store.deleteConversation(id);
  return reply.send({ ok: true });
});
```

**Step 3: Run tests**

Run: `npx vitest run`
Expected: All pass

**Step 4: Commit**

```bash
git add src/portal/server.ts
git commit -m "feat(portal): add chat API endpoints with SSE streaming and conversation CRUD"
```

---

### Task 7: Add Chat Page UI

**Files:**
- Modify: `src/portal/server.ts` (add `/portal/chat` GET route)

**Step 1: Add the chat page route**

Add a new route handler for `GET /portal/chat` that renders a full chat interface. This goes before the wallet route:

```typescript
app.get("/portal/chat", async (_req, reply) => {
  const content = `
    <div style="display:grid; grid-template-columns:260px 1fr; gap:10px; height:calc(100vh - 180px);">
      <div class="card" style="display:flex; flex-direction:column; overflow:hidden;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
          <h3 style="margin:0;">Conversations</h3>
          <button class="primary" id="newChatBtn" style="padding:4px 10px; font-size:12px;">+ New</button>
        </div>
        <input id="convSearch" type="text" placeholder="Search conversations..." style="margin-bottom:8px;" />
        <div id="convList" style="flex:1; overflow-y:auto;"></div>
      </div>
      <div class="card" style="display:flex; flex-direction:column; overflow:hidden;">
        <div id="chatHeader" style="display:flex; justify-content:space-between; align-items:center; padding-bottom:8px; border-bottom:0.5px solid var(--card-border); margin-bottom:8px;">
          <h3 id="chatTitle" style="margin:0;">New chat</h3>
          <div id="chatMeta" class="muted" style="font-size:11px;"></div>
        </div>
        <div id="chatMessages" style="flex:1; overflow-y:auto; padding:8px 0;"></div>
        <div id="streamingIndicator" class="hidden" style="display:flex; align-items:center; gap:8px; padding:8px 0; color:var(--muted); font-size:12px;">
          <span class="spinner"></span>
          <span id="streamStatus">Thinking...</span>
          <span id="streamTokens"></span>
        </div>
        <div style="border-top:0.5px solid var(--card-border); padding-top:10px;">
          <div style="display:flex; gap:8px;">
            <textarea id="chatInput" rows="2" placeholder="Message EdgeCoder..." style="flex:1; resize:none; max-height:200px; font-family:inherit;"></textarea>
            <button class="primary" id="sendBtn" style="align-self:flex-end; padding:8px 16px;">Send</button>
          </div>
          <div class="muted" style="font-size:10px; margin-top:4px;">Enter to send, Shift+Enter for newline. Responses use swarm credits.</div>
        </div>
      </div>
    </div>
    <style>
      .chat-msg { padding:8px 12px; margin:4px 0; border-radius:8px; max-width:85%; word-wrap:break-word; }
      .chat-msg.user { background:var(--brand); color:#fff; margin-left:auto; text-align:right; }
      .chat-msg.assistant { background:var(--bg-soft); margin-right:auto; }
      .chat-msg pre { background:rgba(0,0,0,0.3); padding:8px; border-radius:6px; overflow-x:auto; margin:6px 0; }
      .chat-msg code { font-family:"IBM Plex Mono",ui-monospace,monospace; font-size:13px; }
      .conv-item { padding:8px 10px; border-radius:6px; cursor:pointer; margin:2px 0; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
      .conv-item:hover { background:var(--card-border); }
      .conv-item.active { background:var(--brand); color:#fff; }
      .spinner { width:14px; height:14px; border:2px solid var(--muted); border-top-color:var(--brand); border-radius:50%; animation:spin 0.8s linear infinite; }
      @keyframes spin { to { transform:rotate(360deg); } }
    </style>
  `;
  const script = `
    let activeConvId = null;
    let conversations = [];
    let abortController = null;
    let isStreaming = false;

    function escapeHtml(s) {
      return String(s || "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    function renderMarkdown(text) {
      // Simple markdown: code blocks, inline code, bold, italic, newlines
      let html = escapeHtml(text);
      // Code blocks
      html = html.replace(/\`\`\`(\\w*)?\\n([\\s\\S]*?)\`\`\`/g, function(_, lang, code) {
        return "<pre><code>" + code.trim() + "</code></pre>";
      });
      // Inline code
      html = html.replace(/\`([^\`]+)\`/g, "<code>$1</code>");
      // Bold
      html = html.replace(/\\*\\*(.+?)\\*\\*/g, "<strong>$1</strong>");
      // Italic
      html = html.replace(/\\*(.+?)\\*/g, "<em>$1</em>");
      // Newlines
      html = html.replace(/\\n/g, "<br>");
      return html;
    }

    function renderConversations() {
      const search = (document.getElementById("convSearch").value || "").toLowerCase();
      const list = document.getElementById("convList");
      const filtered = conversations.filter(function(c) {
        return !search || c.title.toLowerCase().includes(search);
      });
      list.innerHTML = filtered.length === 0
        ? "<div class='muted' style='padding:12px;text-align:center;'>No conversations</div>"
        : filtered.map(function(c) {
            const isActive = c.conversationId === activeConvId;
            return "<div class='conv-item " + (isActive ? "active" : "") + "' data-conv-id='" + c.conversationId + "'>" + escapeHtml(c.title) + "</div>";
          }).join("");
    }

    function renderMessages(messages) {
      const container = document.getElementById("chatMessages");
      if (!messages || messages.length === 0) {
        container.innerHTML = "<div style='text-align:center;padding:40px;'><div style='font-size:24px;margin-bottom:12px;'>&#128172;</div><div class='muted'>Start a conversation with EdgeCoder</div><div class='muted' style='font-size:12px;margin-top:8px;'>Your messages are routed through the swarm network</div></div>";
        return;
      }
      container.innerHTML = messages.map(function(m) {
        const content = m.role === "assistant" ? renderMarkdown(m.content) : escapeHtml(m.content);
        return "<div class='chat-msg " + m.role + "'>" + content + "</div>";
      }).join("");
      container.scrollTop = container.scrollHeight;
    }

    async function loadConversations() {
      try {
        const data = await api("/portal/api/conversations", { method: "GET", headers: {} });
        conversations = data.conversations || [];
        renderConversations();
      } catch (err) {
        showToast("Could not load conversations: " + String(err.message || err), true);
      }
    }

    async function loadMessages(convId) {
      try {
        const data = await api("/portal/api/conversations/" + encodeURIComponent(convId) + "/messages", { method: "GET", headers: {} });
        renderMessages(data.messages || []);
      } catch (err) {
        showToast("Could not load messages: " + String(err.message || err), true);
      }
    }

    async function selectConversation(convId) {
      activeConvId = convId;
      renderConversations();
      const conv = conversations.find(function(c) { return c.conversationId === convId; });
      document.getElementById("chatTitle").textContent = conv ? conv.title : "Chat";
      await loadMessages(convId);
    }

    async function createNewChat() {
      try {
        const data = await api("/portal/api/conversations", { method: "POST", body: JSON.stringify({}) });
        await loadConversations();
        await selectConversation(data.conversationId);
      } catch (err) {
        showToast("Could not create chat: " + String(err.message || err), true);
      }
    }

    async function sendMessage() {
      const input = document.getElementById("chatInput");
      const message = input.value.trim();
      if (!message || isStreaming) return;

      if (!activeConvId) {
        await createNewChat();
      }

      input.value = "";
      input.style.height = "auto";

      // Append user message immediately
      const container = document.getElementById("chatMessages");
      container.innerHTML += "<div class='chat-msg user'>" + escapeHtml(message) + "</div>";
      container.scrollTop = container.scrollHeight;

      // Start streaming
      isStreaming = true;
      document.getElementById("sendBtn").disabled = true;
      document.getElementById("streamingIndicator").classList.remove("hidden");
      const startMs = Date.now();
      let tokenCount = 0;
      let fullContent = "";

      try {
        abortController = new AbortController();
        const res = await fetch("/portal/api/chat", {
          method: "POST",
          credentials: "include",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ conversationId: activeConvId, message: message }),
          signal: abortController.signal
        });

        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let assistantEl = document.createElement("div");
        assistantEl.className = "chat-msg assistant";
        container.appendChild(assistantEl);

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          const text = decoder.decode(value, { stream: true });
          const lines = text.split("\\n");
          for (const line of lines) {
            if (!line.startsWith("data: ")) continue;
            const data = line.slice(6);
            if (data === "[DONE]") break;
            try {
              const parsed = JSON.parse(data);
              if (parsed.error) {
                showToast(parsed.error, true);
                break;
              }
              const delta = parsed?.choices?.[0]?.delta?.content;
              if (delta) {
                fullContent += delta;
                tokenCount++;
                assistantEl.innerHTML = renderMarkdown(fullContent);
                container.scrollTop = container.scrollHeight;
              }
            } catch {}
          }
          const elapsed = ((Date.now() - startMs) / 1000).toFixed(1);
          document.getElementById("streamStatus").textContent = "Swarm | " + elapsed + "s";
          document.getElementById("streamTokens").textContent = tokenCount + " tokens";
        }

        // Auto-rename first message
        if (conversations.find(function(c) { return c.conversationId === activeConvId && c.title === "New chat"; })) {
          const title = message.length > 40 ? message.substring(0, 40) + "..." : message;
          await api("/portal/api/conversations/" + encodeURIComponent(activeConvId), {
            method: "PATCH",
            body: JSON.stringify({ title: title })
          }).catch(function() {});
          await loadConversations();
        }
      } catch (err) {
        if (err.name !== "AbortError") {
          showToast("Chat error: " + String(err.message || err), true);
        }
      } finally {
        isStreaming = false;
        abortController = null;
        document.getElementById("sendBtn").disabled = false;
        document.getElementById("streamingIndicator").classList.add("hidden");
      }
    }

    // Event listeners
    document.getElementById("newChatBtn").addEventListener("click", createNewChat);
    document.getElementById("sendBtn").addEventListener("click", sendMessage);
    document.getElementById("chatInput").addEventListener("keydown", function(e) {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
    document.getElementById("chatInput").addEventListener("input", function() {
      this.style.height = "auto";
      this.style.height = Math.min(this.scrollHeight, 200) + "px";
    });
    document.getElementById("convList").addEventListener("click", function(e) {
      const item = e.target.closest(".conv-item");
      if (item) selectConversation(item.getAttribute("data-conv-id"));
    });
    document.getElementById("convSearch").addEventListener("input", renderConversations);

    // Init
    (async function() {
      await requireAuth();
      await loadConversations();
      if (conversations.length > 0) {
        await selectConversation(conversations[0].conversationId);
      } else {
        renderMessages([]);
      }
    })().catch(function(err) {
      showToast("Could not initialize chat: " + String(err.message || err), true);
    });
  `;
  return reply.type("text/html").send(portalAuthedPageHtml({
    title: "EdgeCoder Portal | Chat",
    activeTab: "chat",
    heading: "Chat",
    subtitle: "AI assistant powered by the EdgeCoder swarm network.",
    content,
    script
  }));
});
```

**Step 2: Run tests**

Run: `npx vitest run`
Expected: All pass

**Step 3: Commit**

```bash
git add src/portal/server.ts
git commit -m "feat(portal): add chat page with conversation sidebar and SSE streaming"
```

---

### Task 8: Update Settings Page Theme Picker

**Files:**
- Modify: `src/portal/server.ts` (settings page, around line 5129)

**Step 1: Find and update theme options**

In the settings page route handler (line ~5129), find the theme radio buttons or select options. Change:
- "midnight" label → "Midnight" (keep value "midnight")
- "emerald" label → "Emerald" (keep value "emerald")
- "light" label → "Warm" with value "warm" (replace the old "light" option)

Also update any default selection logic to default to "warm".

**Step 2: Update the theme persistence API**

If the settings page calls an API to save theme preference (e.g., `PATCH /settings`), ensure the valid theme values are `warm | midnight | emerald` instead of the old set.

**Step 3: Run tests**

Run: `npx vitest run`
Expected: All pass

**Step 4: Commit**

```bash
git add src/portal/server.ts
git commit -m "feat(portal): update settings theme picker to warm/midnight/emerald dark variants"
```

---

### Task 9: Update the Download Page Theme Compatibility

**Files:**
- Modify: `src/portal/server.ts` (download page, around line 5245)

**Step 1: Check download page for hardcoded light colors**

The download page was recently redesigned with its own inline styles. Scan for any hardcoded light-theme colors (e.g., `#ffffff`, `#f3f6fb`, `rgba(255,255,255`) in the download page content and replace them with CSS variable references (`var(--card)`, `var(--bg)`, etc.).

**Step 2: Run tests**

Run: `npx vitest run`
Expected: All pass

**Step 3: Commit**

```bash
git add src/portal/server.ts
git commit -m "fix(portal): update download page colors to use CSS variables for dark theme"
```

---

### Task 10: Final Integration Test and Deploy

**Files:**
- Test: Run full test suite
- Deploy: Fly.io

**Step 1: Run full test suite**

Run: `npx vitest run`
Expected: All pass

**Step 2: Build TypeScript**

Run: `npx tsc -p tsconfig.json`
Expected: No errors

**Step 3: Deploy to Fly.io**

Run: `fly deploy -c deploy/fly/fly.portal.toml`
Expected: Successful deployment

**Step 4: Verify live**

Open: `https://edgecoder.io/portal/download`
Verify: Dark warm theme applied

Open: `https://edgecoder.io/portal/chat`
Verify: Chat page loads with conversation sidebar

**Step 5: Commit any final fixes**

If any deployment fixes needed, commit them.

**Step 6: Tag release**

```bash
git tag v1.2.0
git push origin v1.2.0
```
